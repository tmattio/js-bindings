[@@@js.dummy "!! This code has been generated by gen_js_api !!"]
[@@@ocaml.warning "-7-32-39"]
[@@@ocaml.warning "-7-11-32-33-39"]
open Es2020
open Node_globals
module Perf_hooks =
  struct
    module EntryType =
      struct
        type t =
          [ `function_  | `gc  | `http  | `http2  | `mark  | `measure 
          | `node ]
        let rec t_of_js : Ojs.t -> t =
          fun (x2 : Ojs.t) ->
            let x3 = x2 in
            match Ojs.string_of_js x3 with
            | "function" -> `function_
            | "gc" -> `gc
            | "http" -> `http
            | "http2" -> `http2
            | "mark" -> `mark
            | "measure" -> `measure
            | "node" -> `node
            | _ -> assert false
        and t_to_js : t -> Ojs.t =
          fun
            (x1 :
              [ `function_  | `gc  | `http  | `http2  | `mark  | `measure 
              | `node ])
            ->
            match x1 with
            | `function_ -> Ojs.string_to_js "function"
            | `gc -> Ojs.string_to_js "gc"
            | `http -> Ojs.string_to_js "http"
            | `http2 -> Ojs.string_to_js "http2"
            | `mark -> Ojs.string_to_js "mark"
            | `measure -> Ojs.string_to_js "measure"
            | `node -> Ojs.string_to_js "node"
      end
    module AnonymousInterface0 =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x5 : Ojs.t) -> x5
        and t_to_js : t -> Ojs.t = fun (x4 : Ojs.t) -> x4
        let (get_entry_types : t -> EntryType.t list) =
          fun (x6 : t) ->
            Ojs.list_of_js EntryType.t_of_js
              (Ojs.get_prop_ascii (t_to_js x6) "entryTypes")
        let (set_entry_types : t -> EntryType.t list -> unit) =
          fun (x8 : t) ->
            fun (x9 : EntryType.t list) ->
              Ojs.set_prop_ascii (t_to_js x8) "entryTypes"
                (Ojs.list_to_js EntryType.t_to_js x9)
        let (get_buffered : t -> bool) =
          fun (x11 : t) ->
            Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x11) "buffered")
        let (set_buffered : t -> bool -> unit) =
          fun (x12 : t) ->
            fun (x13 : bool) ->
              Ojs.set_prop_ascii (t_to_js x12) "buffered"
                (Ojs.bool_to_js x13)
      end
    module PerformanceEntry =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x15 : Ojs.t) -> x15
        and t_to_js : t -> Ojs.t = fun (x14 : Ojs.t) -> x14
        let (get_duration : t -> int) =
          fun (x16 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x16) "duration")
        let (get_name : t -> string) =
          fun (x17 : t) ->
            Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x17) "name")
        let (get_start_time : t -> int) =
          fun (x18 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x18) "startTime")
        let (get_entry_type : t -> EntryType.t) =
          fun (x19 : t) ->
            EntryType.t_of_js (Ojs.get_prop_ascii (t_to_js x19) "entryType")
        let (get_kind : t -> int) =
          fun (x20 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x20) "kind")
        let (get_flags : t -> int) =
          fun (x21 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x21) "flags")
      end
    module PerformanceNodeTiming =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x23 : Ojs.t) -> x23
        and t_to_js : t -> Ojs.t = fun (x22 : Ojs.t) -> x22
        let (get_bootstrap_complete : t -> int) =
          fun (x24 : t) ->
            Ojs.int_of_js
              (Ojs.get_prop_ascii (t_to_js x24) "bootstrapComplete")
        let (get_environment : t -> int) =
          fun (x25 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x25) "environment")
        let (get_idle_time : t -> int) =
          fun (x26 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x26) "idleTime")
        let (get_loop_exit : t -> int) =
          fun (x27 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x27) "loopExit")
        let (get_loop_start : t -> int) =
          fun (x28 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x28) "loopStart")
        let (get_v8Start : t -> int) =
          fun (x29 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x29) "v8Start")
        let (cast : t -> PerformanceEntry.t) =
          fun (x30 : t) -> PerformanceEntry.t_of_js (t_to_js x30)
      end
    module EventLoopUtilization =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x32 : Ojs.t) -> x32
        and t_to_js : t -> Ojs.t = fun (x31 : Ojs.t) -> x31
        let (get_idle : t -> int) =
          fun (x33 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x33) "idle")
        let (set_idle : t -> int -> unit) =
          fun (x34 : t) ->
            fun (x35 : int) ->
              Ojs.set_prop_ascii (t_to_js x34) "idle" (Ojs.int_to_js x35)
        let (get_active : t -> int) =
          fun (x36 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x36) "active")
        let (set_active : t -> int -> unit) =
          fun (x37 : t) ->
            fun (x38 : int) ->
              Ojs.set_prop_ascii (t_to_js x37) "active" (Ojs.int_to_js x38)
        let (get_utilization : t -> int) =
          fun (x39 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x39) "utilization")
        let (set_utilization : t -> int -> unit) =
          fun (x40 : t) ->
            fun (x41 : int) ->
              Ojs.set_prop_ascii (t_to_js x40) "utilization"
                (Ojs.int_to_js x41)
      end
    module Performance =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x43 : Ojs.t) -> x43
        and t_to_js : t -> Ojs.t = fun (x42 : Ojs.t) -> x42
        let (clear_marks : t -> ?name:string -> unit -> unit) =
          fun (x47 : t) ->
            fun ?name:(x44 : string option) ->
              fun () ->
                ignore
                  (let x48 = t_to_js x47 in
                   Ojs.call (Ojs.get_prop_ascii x48 "clearMarks") "apply"
                     [|x48;((let x45 =
                               Ojs.new_obj
                                 (Ojs.get_prop_ascii Ojs.global "Array") 
                                 [||] in
                             (match x44 with
                              | Some x46 ->
                                  ignore
                                    (Ojs.call x45 "push"
                                       [|(Ojs.string_to_js x46)|])
                              | None -> ());
                             x45))|])
        let (mark : t -> ?name:string -> unit -> unit) =
          fun (x52 : t) ->
            fun ?name:(x49 : string option) ->
              fun () ->
                ignore
                  (let x53 = t_to_js x52 in
                   Ojs.call (Ojs.get_prop_ascii x53 "mark") "apply"
                     [|x53;((let x50 =
                               Ojs.new_obj
                                 (Ojs.get_prop_ascii Ojs.global "Array") 
                                 [||] in
                             (match x49 with
                              | Some x51 ->
                                  ignore
                                    (Ojs.call x50 "push"
                                       [|(Ojs.string_to_js x51)|])
                              | None -> ());
                             x50))|])
        let (measure :
          t -> name:string -> start_mark:string -> end_mark:string -> unit) =
          fun (x57 : t) ->
            fun ~name:(x54 : string) ->
              fun ~start_mark:(x55 : string) ->
                fun ~end_mark:(x56 : string) ->
                  ignore
                    (Ojs.call (t_to_js x57) "measure"
                       [|(Ojs.string_to_js x54);(Ojs.string_to_js x55);(
                         Ojs.string_to_js x56)|])
        let (get_node_timing : t -> PerformanceNodeTiming.t) =
          fun (x58 : t) ->
            PerformanceNodeTiming.t_of_js
              (Ojs.get_prop_ascii (t_to_js x58) "nodeTiming")
        let (now : t -> int) =
          fun (x59 : t) -> Ojs.int_of_js (Ojs.call (t_to_js x59) "now" [||])
        let (get_time_origin : t -> int) =
          fun (x60 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x60) "timeOrigin")
        let (timerify : t -> fn:'T -> 'T) =
          fun (x62 : t) ->
            fun ~fn:(x61 : 'T) ->
              Obj.magic
                (Ojs.call (t_to_js x62) "timerify" [|(Obj.magic x61)|])
        let (event_loop_utilization :
          t ->
            ?util1:EventLoopUtilization.t ->
              ?util2:EventLoopUtilization.t -> unit -> EventLoopUtilization.t)
          =
          fun (x68 : t) ->
            fun ?util1:(x63 : EventLoopUtilization.t option) ->
              fun ?util2:(x64 : EventLoopUtilization.t option) ->
                fun () ->
                  EventLoopUtilization.t_of_js
                    (let x69 = t_to_js x68 in
                     Ojs.call (Ojs.get_prop_ascii x69 "eventLoopUtilization")
                       "apply"
                       [|x69;((let x65 =
                                 Ojs.new_obj
                                   (Ojs.get_prop_ascii Ojs.global "Array")
                                   [||] in
                               (match x63 with
                                | Some x67 ->
                                    ignore
                                      (Ojs.call x65 "push"
                                         [|(EventLoopUtilization.t_to_js x67)|])
                                | None -> ());
                               (match x64 with
                                | Some x66 ->
                                    ignore
                                      (Ojs.call x65 "push"
                                         [|(EventLoopUtilization.t_to_js x66)|])
                                | None -> ());
                               x65))|])
      end
    module PerformanceObserverEntryList =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x71 : Ojs.t) -> x71
        and t_to_js : t -> Ojs.t = fun (x70 : Ojs.t) -> x70
        let (get_entries : t -> PerformanceEntry.t list) =
          fun (x72 : t) ->
            Ojs.list_of_js PerformanceEntry.t_of_js
              (Ojs.call (t_to_js x72) "getEntries" [||])
        let (get_entries_by_name :
          t ->
            name:string ->
              ?type_:EntryType.t -> unit -> PerformanceEntry.t list)
          =
          fun (x78 : t) ->
            fun ~name:(x74 : string) ->
              fun ?type_:(x75 : EntryType.t option) ->
                fun () ->
                  Ojs.list_of_js PerformanceEntry.t_of_js
                    (let x79 = t_to_js x78 in
                     Ojs.call (Ojs.get_prop_ascii x79 "getEntriesByName")
                       "apply"
                       [|x79;((let x76 =
                                 Ojs.new_obj
                                   (Ojs.get_prop_ascii Ojs.global "Array")
                                   [||] in
                               ignore
                                 (Ojs.call x76 "push"
                                    [|(Ojs.string_to_js x74)|]);
                               (match x75 with
                                | Some x77 ->
                                    ignore
                                      (Ojs.call x76 "push"
                                         [|(EntryType.t_to_js x77)|])
                                | None -> ());
                               x76))|])
        let (get_entries_by_type :
          t -> type_:EntryType.t -> PerformanceEntry.t list) =
          fun (x82 : t) ->
            fun ~type_:(x81 : EntryType.t) ->
              Ojs.list_of_js PerformanceEntry.t_of_js
                (Ojs.call (t_to_js x82) "getEntriesByType"
                   [|(EntryType.t_to_js x81)|])
      end
    module PerformanceObserverCallback =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x85 : Ojs.t) -> x85
        and t_to_js : t -> Ojs.t = fun (x84 : Ojs.t) -> x84
      end
    module PerformanceObserver =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x87 : Ojs.t) -> x87
        and t_to_js : t -> Ojs.t = fun (x86 : Ojs.t) -> x86
        let (create : callback:PerformanceObserverCallback.t -> t) =
          fun ~callback:(x88 : PerformanceObserverCallback.t) ->
            t_of_js
              (Ojs.new_obj
                 (Ojs.get_prop_ascii Import.perf_hooks "PerformanceObserver")
                 [|(PerformanceObserverCallback.t_to_js x88)|])
        let (disconnect : t -> unit) =
          fun (x89 : t) -> ignore (Ojs.call (t_to_js x89) "disconnect" [||])
        let (observe : t -> options:AnonymousInterface0.t -> unit) =
          fun (x91 : t) ->
            fun ~options:(x90 : AnonymousInterface0.t) ->
              ignore
                (Ojs.call (t_to_js x91) "observe"
                   [|(AnonymousInterface0.t_to_js x90)|])
        let (cast : t -> Node_async_hooks.Async_hooks.AsyncResource.t) =
          fun (x92 : t) ->
            Node_async_hooks.Async_hooks.AsyncResource.t_of_js (t_to_js x92)
      end
    module Constants =
      struct
        let (node_performance_gc_major : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_MAJOR")
        let (node_performance_gc_minor : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_MINOR")
        let (node_performance_gc_incremental : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_INCREMENTAL")
        let (node_performance_gc_weakcb : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_WEAKCB")
        let (node_performance_gc_flags_no : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_FLAGS_NO")
        let (node_performance_gc_flags_construct_retained : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED")
        let (node_performance_gc_flags_forced : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_FLAGS_FORCED")
        let (node_performance_gc_flags_synchronous_phantom_processing : 
          int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING")
        let (node_performance_gc_flags_all_available_garbage : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE")
        let (node_performance_gc_flags_all_external_memory : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY")
        let (node_performance_gc_flags_schedule_idle : int) =
          Ojs.int_of_js
            (Ojs.get_prop_ascii
               (Ojs.get_prop_ascii Import.perf_hooks "constants")
               "NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE")
      end
    let (performance : Performance.t) =
      Performance.t_of_js
        (Ojs.get_prop_ascii Import.perf_hooks "performance")
    module EventLoopMonitorOptions =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x94 : Ojs.t) -> x94
        and t_to_js : t -> Ojs.t = fun (x93 : Ojs.t) -> x93
        let (get_resolution : t -> int) =
          fun (x95 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x95) "resolution")
        let (set_resolution : t -> int -> unit) =
          fun (x96 : t) ->
            fun (x97 : int) ->
              Ojs.set_prop_ascii (t_to_js x96) "resolution"
                (Ojs.int_to_js x97)
      end
    module EventLoopDelayMonitor =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x99 : Ojs.t) -> x99
        and t_to_js : t -> Ojs.t = fun (x98 : Ojs.t) -> x98
        let (enable : t -> bool) =
          fun (x100 : t) ->
            Ojs.bool_of_js (Ojs.call (t_to_js x100) "enable" [||])
        let (disable : t -> bool) =
          fun (x101 : t) ->
            Ojs.bool_of_js (Ojs.call (t_to_js x101) "disable" [||])
        let (reset : t -> unit) =
          fun (x102 : t) -> ignore (Ojs.call (t_to_js x102) "reset" [||])
        let (percentile : t -> percentile:int -> int) =
          fun (x104 : t) ->
            fun ~percentile:(x103 : int) ->
              Ojs.int_of_js
                (Ojs.call (t_to_js x104) "percentile"
                   [|(Ojs.int_to_js x103)|])
        let (get_percentiles : t -> (int, int) Map.t) =
          fun (x105 : t) ->
            Map.t_of_js Ojs.int_of_js Ojs.int_of_js
              (Ojs.get_prop_ascii (t_to_js x105) "percentiles")
        let (get_exceeds : t -> int) =
          fun (x108 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x108) "exceeds")
        let (get_min : t -> int) =
          fun (x109 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x109) "min")
        let (get_max : t -> int) =
          fun (x110 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x110) "max")
        let (get_mean : t -> int) =
          fun (x111 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x111) "mean")
        let (get_stddev : t -> int) =
          fun (x112 : t) ->
            Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x112) "stddev")
      end
    let (monitor_event_loop_delay :
      ?options:EventLoopMonitorOptions.t -> unit -> EventLoopDelayMonitor.t)
      =
      fun ?options:(x113 : EventLoopMonitorOptions.t option) ->
        fun () ->
          EventLoopDelayMonitor.t_of_js
            (let x116 = Import.perf_hooks in
             Ojs.call (Ojs.get_prop_ascii x116 "monitorEventLoopDelay")
               "apply"
               [|x116;((let x114 =
                          Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array")
                            [||] in
                        (match x113 with
                         | Some x115 ->
                             ignore
                               (Ojs.call x114 "push"
                                  [|(EventLoopMonitorOptions.t_to_js x115)|])
                         | None -> ());
                        x114))|])
  end
