[@@@js.dummy "!! This code has been generated by gen_js_api !!"]
[@@@ocaml.warning "-7-32-39"]
[@@@ocaml.warning "-7-11-32-33-39"]
open Es2020
open Globals
module Internal =
  struct
    module AnonymousInterfaces = struct  end
    module Types =
      struct
        open AnonymousInterfaces
        type v8_DefaultDeserializer =
          [ `V8_DefaultDeserializer  | `V8_Deserializer ] intf
        and v8_DefaultSerializer =
          [ `V8_DefaultSerializer  | `V8_Serializer ] intf
        and v8_Deserializer = [ `V8_Deserializer ] intf
        and v8_DoesZapCodeSpaceFlag = [ `L_n_0  | `L_n_1 ]
        and v8_HeapCodeStatistics = [ `V8_HeapCodeStatistics ] intf
        and v8_HeapInfo = [ `V8_HeapInfo ] intf
        and v8_HeapSpaceInfo = [ `V8_HeapSpaceInfo ] intf
        and v8_Serializer = [ `V8_Serializer ] intf
        let rec v8_DefaultDeserializer_of_js :
          Ojs.t -> v8_DefaultDeserializer = Obj.magic
        and v8_DefaultDeserializer_to_js : v8_DefaultDeserializer -> Ojs.t =
          Obj.magic
        and v8_DefaultSerializer_of_js : Ojs.t -> v8_DefaultSerializer =
          Obj.magic
        and v8_DefaultSerializer_to_js : v8_DefaultSerializer -> Ojs.t =
          Obj.magic
        and v8_Deserializer_of_js : Ojs.t -> v8_Deserializer = Obj.magic
        and v8_Deserializer_to_js : v8_Deserializer -> Ojs.t = Obj.magic
        and v8_DoesZapCodeSpaceFlag_of_js : Ojs.t -> v8_DoesZapCodeSpaceFlag
          =
          fun (x2 : Ojs.t) ->
            let x3 = x2 in
            match Ojs.int_of_js x3 with
            | 0 -> `L_n_0
            | 1 -> `L_n_1
            | _ -> assert false
        and v8_DoesZapCodeSpaceFlag_to_js : v8_DoesZapCodeSpaceFlag -> Ojs.t
          =
          fun (x1 : [ `L_n_0  | `L_n_1 ]) ->
            match x1 with
            | `L_n_0 -> Ojs.int_to_js 0
            | `L_n_1 -> Ojs.int_to_js 1
        and v8_HeapCodeStatistics_of_js : Ojs.t -> v8_HeapCodeStatistics =
          Obj.magic
        and v8_HeapCodeStatistics_to_js : v8_HeapCodeStatistics -> Ojs.t =
          Obj.magic
        and v8_HeapInfo_of_js : Ojs.t -> v8_HeapInfo = Obj.magic
        and v8_HeapInfo_to_js : v8_HeapInfo -> Ojs.t = Obj.magic
        and v8_HeapSpaceInfo_of_js : Ojs.t -> v8_HeapSpaceInfo = Obj.magic
        and v8_HeapSpaceInfo_to_js : v8_HeapSpaceInfo -> Ojs.t = Obj.magic
        and v8_Serializer_of_js : Ojs.t -> v8_Serializer = Obj.magic
        and v8_Serializer_to_js : v8_Serializer -> Ojs.t = Obj.magic
      end
  end
open Internal
open AnonymousInterfaces
open Types
module V8 =
  struct
    open Stream
    module HeapSpaceInfo =
      struct
        type t = v8_HeapSpaceInfo
        let rec t_of_js : Ojs.t -> t =
          fun (x5 : Ojs.t) -> v8_HeapSpaceInfo_of_js x5
        and t_to_js : t -> Ojs.t =
          fun (x4 : v8_HeapSpaceInfo) -> v8_HeapSpaceInfo_to_js x4
        let (get_space_name : t -> string) =
          fun (x6 : t) ->
            Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x6) "space_name")
        let (set_space_name : t -> string -> unit) =
          fun (x7 : t) ->
            fun (x8 : string) ->
              Ojs.set_prop_ascii (t_to_js x7) "space_name"
                (Ojs.string_to_js x8)
        let (get_space_size : t -> float) =
          fun (x9 : t) ->
            Ojs.float_of_js (Ojs.get_prop_ascii (t_to_js x9) "space_size")
        let (set_space_size : t -> float -> unit) =
          fun (x10 : t) ->
            fun (x11 : float) ->
              Ojs.set_prop_ascii (t_to_js x10) "space_size"
                (Ojs.float_to_js x11)
        let (get_space_used_size : t -> float) =
          fun (x12 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x12) "space_used_size")
        let (set_space_used_size : t -> float -> unit) =
          fun (x13 : t) ->
            fun (x14 : float) ->
              Ojs.set_prop_ascii (t_to_js x13) "space_used_size"
                (Ojs.float_to_js x14)
        let (get_space_available_size : t -> float) =
          fun (x15 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x15) "space_available_size")
        let (set_space_available_size : t -> float -> unit) =
          fun (x16 : t) ->
            fun (x17 : float) ->
              Ojs.set_prop_ascii (t_to_js x16) "space_available_size"
                (Ojs.float_to_js x17)
        let (get_physical_space_size : t -> float) =
          fun (x18 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x18) "physical_space_size")
        let (set_physical_space_size : t -> float -> unit) =
          fun (x19 : t) ->
            fun (x20 : float) ->
              Ojs.set_prop_ascii (t_to_js x19) "physical_space_size"
                (Ojs.float_to_js x20)
      end
    module DoesZapCodeSpaceFlag =
      struct
        type t = v8_DoesZapCodeSpaceFlag
        let rec t_of_js : Ojs.t -> t =
          fun (x22 : Ojs.t) -> v8_DoesZapCodeSpaceFlag_of_js x22
        and t_to_js : t -> Ojs.t =
          fun (x21 : v8_DoesZapCodeSpaceFlag) ->
            v8_DoesZapCodeSpaceFlag_to_js x21
      end
    module HeapInfo =
      struct
        type t = v8_HeapInfo
        let rec t_of_js : Ojs.t -> t =
          fun (x24 : Ojs.t) -> v8_HeapInfo_of_js x24
        and t_to_js : t -> Ojs.t =
          fun (x23 : v8_HeapInfo) -> v8_HeapInfo_to_js x23
        let (get_total_heap_size : t -> float) =
          fun (x25 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x25) "total_heap_size")
        let (set_total_heap_size : t -> float -> unit) =
          fun (x26 : t) ->
            fun (x27 : float) ->
              Ojs.set_prop_ascii (t_to_js x26) "total_heap_size"
                (Ojs.float_to_js x27)
        let (get_total_heap_size_executable : t -> float) =
          fun (x28 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x28) "total_heap_size_executable")
        let (set_total_heap_size_executable : t -> float -> unit) =
          fun (x29 : t) ->
            fun (x30 : float) ->
              Ojs.set_prop_ascii (t_to_js x29) "total_heap_size_executable"
                (Ojs.float_to_js x30)
        let (get_total_physical_size : t -> float) =
          fun (x31 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x31) "total_physical_size")
        let (set_total_physical_size : t -> float -> unit) =
          fun (x32 : t) ->
            fun (x33 : float) ->
              Ojs.set_prop_ascii (t_to_js x32) "total_physical_size"
                (Ojs.float_to_js x33)
        let (get_total_available_size : t -> float) =
          fun (x34 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x34) "total_available_size")
        let (set_total_available_size : t -> float -> unit) =
          fun (x35 : t) ->
            fun (x36 : float) ->
              Ojs.set_prop_ascii (t_to_js x35) "total_available_size"
                (Ojs.float_to_js x36)
        let (get_used_heap_size : t -> float) =
          fun (x37 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x37) "used_heap_size")
        let (set_used_heap_size : t -> float -> unit) =
          fun (x38 : t) ->
            fun (x39 : float) ->
              Ojs.set_prop_ascii (t_to_js x38) "used_heap_size"
                (Ojs.float_to_js x39)
        let (get_heap_size_limit : t -> float) =
          fun (x40 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x40) "heap_size_limit")
        let (set_heap_size_limit : t -> float -> unit) =
          fun (x41 : t) ->
            fun (x42 : float) ->
              Ojs.set_prop_ascii (t_to_js x41) "heap_size_limit"
                (Ojs.float_to_js x42)
        let (get_malloced_memory : t -> float) =
          fun (x43 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x43) "malloced_memory")
        let (set_malloced_memory : t -> float -> unit) =
          fun (x44 : t) ->
            fun (x45 : float) ->
              Ojs.set_prop_ascii (t_to_js x44) "malloced_memory"
                (Ojs.float_to_js x45)
        let (get_peak_malloced_memory : t -> float) =
          fun (x46 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x46) "peak_malloced_memory")
        let (set_peak_malloced_memory : t -> float -> unit) =
          fun (x47 : t) ->
            fun (x48 : float) ->
              Ojs.set_prop_ascii (t_to_js x47) "peak_malloced_memory"
                (Ojs.float_to_js x48)
        let (get_does_zap_garbage : t -> v8_DoesZapCodeSpaceFlag) =
          fun (x49 : t) ->
            v8_DoesZapCodeSpaceFlag_of_js
              (Ojs.get_prop_ascii (t_to_js x49) "does_zap_garbage")
        let (set_does_zap_garbage : t -> v8_DoesZapCodeSpaceFlag -> unit) =
          fun (x50 : t) ->
            fun (x51 : v8_DoesZapCodeSpaceFlag) ->
              Ojs.set_prop_ascii (t_to_js x50) "does_zap_garbage"
                (v8_DoesZapCodeSpaceFlag_to_js x51)
        let (get_number_of_native_contexts : t -> float) =
          fun (x52 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x52) "number_of_native_contexts")
        let (set_number_of_native_contexts : t -> float -> unit) =
          fun (x53 : t) ->
            fun (x54 : float) ->
              Ojs.set_prop_ascii (t_to_js x53) "number_of_native_contexts"
                (Ojs.float_to_js x54)
        let (get_number_of_detached_contexts : t -> float) =
          fun (x55 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x55) "number_of_detached_contexts")
        let (set_number_of_detached_contexts : t -> float -> unit) =
          fun (x56 : t) ->
            fun (x57 : float) ->
              Ojs.set_prop_ascii (t_to_js x56) "number_of_detached_contexts"
                (Ojs.float_to_js x57)
      end
    module HeapCodeStatistics =
      struct
        type t = v8_HeapCodeStatistics
        let rec t_of_js : Ojs.t -> t =
          fun (x59 : Ojs.t) -> v8_HeapCodeStatistics_of_js x59
        and t_to_js : t -> Ojs.t =
          fun (x58 : v8_HeapCodeStatistics) ->
            v8_HeapCodeStatistics_to_js x58
        let (get_code_and_metadata_size : t -> float) =
          fun (x60 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x60) "code_and_metadata_size")
        let (set_code_and_metadata_size : t -> float -> unit) =
          fun (x61 : t) ->
            fun (x62 : float) ->
              Ojs.set_prop_ascii (t_to_js x61) "code_and_metadata_size"
                (Ojs.float_to_js x62)
        let (get_bytecode_and_metadata_size : t -> float) =
          fun (x63 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x63) "bytecode_and_metadata_size")
        let (set_bytecode_and_metadata_size : t -> float -> unit) =
          fun (x64 : t) ->
            fun (x65 : float) ->
              Ojs.set_prop_ascii (t_to_js x64) "bytecode_and_metadata_size"
                (Ojs.float_to_js x65)
        let (get_external_script_source_size : t -> float) =
          fun (x66 : t) ->
            Ojs.float_of_js
              (Ojs.get_prop_ascii (t_to_js x66) "external_script_source_size")
        let (set_external_script_source_size : t -> float -> unit) =
          fun (x67 : t) ->
            fun (x68 : float) ->
              Ojs.set_prop_ascii (t_to_js x67) "external_script_source_size"
                (Ojs.float_to_js x68)
      end
    let (cachedDataVersionTag : unit -> float) =
      fun () ->
        Ojs.float_of_js (Ojs.call Import.v8 "cachedDataVersionTag" [||])
    let (getHeapStatistics : unit -> v8_HeapInfo) =
      fun () ->
        v8_HeapInfo_of_js (Ojs.call Import.v8 "getHeapStatistics" [||])
    let (getHeapSpaceStatistics : unit -> v8_HeapSpaceInfo list) =
      fun () ->
        Ojs.list_of_js v8_HeapSpaceInfo_of_js
          (Ojs.call Import.v8 "getHeapSpaceStatistics" [||])
    let (setFlagsFromString : flags:string -> unit) =
      fun ~flags:(x70 : string) ->
        ignore
          (Ojs.call Import.v8 "setFlagsFromString" [|(Ojs.string_to_js x70)|])
    let (getHeapSnapshot : unit -> Stream.Readable.t) =
      fun () ->
        Stream.Readable.t_of_js (Ojs.call Import.v8 "getHeapSnapshot" [||])
    let (writeHeapSnapshot : ?fileName:string -> unit -> string) =
      fun ?fileName:(x71 : string option) ->
        fun () ->
          Ojs.string_of_js
            (let x74 = Import.v8 in
             Ojs.call (Ojs.get_prop_ascii x74 "writeHeapSnapshot") "apply"
               [|x74;((let x72 =
                         Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array")
                           [||] in
                       (match x71 with
                        | Some x73 ->
                            ignore
                              (Ojs.call x72 "push" [|(Ojs.string_to_js x73)|])
                        | None -> ());
                       x72))|])
    let (getHeapCodeStatistics : unit -> v8_HeapCodeStatistics) =
      fun () ->
        v8_HeapCodeStatistics_of_js
          (Ojs.call Import.v8 "getHeapCodeStatistics" [||])
    module Serializer =
      struct
        type t = v8_Serializer
        let rec t_of_js : Ojs.t -> t =
          fun (x76 : Ojs.t) -> v8_Serializer_of_js x76
        and t_to_js : t -> Ojs.t =
          fun (x75 : v8_Serializer) -> v8_Serializer_to_js x75
        let (writeHeader : t -> unit) =
          fun (x77 : t) -> ignore (Ojs.call (t_to_js x77) "writeHeader" [||])
        let (writeValue : t -> val_:any -> bool) =
          fun (x79 : t) ->
            fun ~val_:(x78 : any) ->
              Ojs.bool_of_js
                (Ojs.call (t_to_js x79) "writeValue" [|(any_to_js x78)|])
        let (releaseBuffer : t -> Buffer.t) =
          fun (x80 : t) ->
            Buffer.t_of_js (Ojs.call (t_to_js x80) "releaseBuffer" [||])
        let (transferArrayBuffer :
          t -> id:float -> arrayBuffer:ArrayBuffer.t -> unit) =
          fun (x83 : t) ->
            fun ~id:(x81 : float) ->
              fun ~arrayBuffer:(x82 : ArrayBuffer.t) ->
                ignore
                  (Ojs.call (t_to_js x83) "transferArrayBuffer"
                     [|(Ojs.float_to_js x81);(ArrayBuffer.t_to_js x82)|])
        let (writeUint32 : t -> value:float -> unit) =
          fun (x85 : t) ->
            fun ~value:(x84 : float) ->
              ignore
                (Ojs.call (t_to_js x85) "writeUint32"
                   [|(Ojs.float_to_js x84)|])
        let (writeUint64 : t -> hi:float -> lo:float -> unit) =
          fun (x88 : t) ->
            fun ~hi:(x86 : float) ->
              fun ~lo:(x87 : float) ->
                ignore
                  (Ojs.call (t_to_js x88) "writeUint64"
                     [|(Ojs.float_to_js x86);(Ojs.float_to_js x87)|])
        let (writeDouble : t -> value:float -> unit) =
          fun (x90 : t) ->
            fun ~value:(x89 : float) ->
              ignore
                (Ojs.call (t_to_js x90) "writeDouble"
                   [|(Ojs.float_to_js x89)|])
        let (writeRawBytes : t -> buffer:TypedArray.t -> unit) =
          fun (x92 : t) ->
            fun ~buffer:(x91 : TypedArray.t) ->
              ignore
                (Ojs.call (t_to_js x92) "writeRawBytes"
                   [|(TypedArray.t_to_js x91)|])
      end
    module DefaultSerializer =
      struct
        type t = v8_DefaultSerializer
        let rec t_of_js : Ojs.t -> t =
          fun (x94 : Ojs.t) -> v8_DefaultSerializer_of_js x94
        and t_to_js : t -> Ojs.t =
          fun (x93 : v8_DefaultSerializer) -> v8_DefaultSerializer_to_js x93
        let (cast : t -> v8_Serializer) =
          fun (x95 : t) -> v8_Serializer_of_js (t_to_js x95)
      end
    module Deserializer =
      struct
        type t = v8_Deserializer
        let rec t_of_js : Ojs.t -> t =
          fun (x97 : Ojs.t) -> v8_Deserializer_of_js x97
        and t_to_js : t -> Ojs.t =
          fun (x96 : v8_Deserializer) -> v8_Deserializer_to_js x96
        let (create : data:TypedArray.t -> t) =
          fun ~data:(x98 : TypedArray.t) ->
            t_of_js
              (Ojs.new_obj (Ojs.get_prop_ascii Import.v8 "Deserializer")
                 [|(TypedArray.t_to_js x98)|])
        let (readHeader : t -> bool) =
          fun (x99 : t) ->
            Ojs.bool_of_js (Ojs.call (t_to_js x99) "readHeader" [||])
        let (readValue : t -> any) =
          fun (x100 : t) ->
            any_of_js (Ojs.call (t_to_js x100) "readValue" [||])
        let (transferArrayBuffer :
          t -> id:float -> arrayBuffer:ArrayBuffer.t -> unit) =
          fun (x103 : t) ->
            fun ~id:(x101 : float) ->
              fun ~arrayBuffer:(x102 : ArrayBuffer.t) ->
                ignore
                  (Ojs.call (t_to_js x103) "transferArrayBuffer"
                     [|(Ojs.float_to_js x101);(ArrayBuffer.t_to_js x102)|])
        let (getWireFormatVersion : t -> float) =
          fun (x104 : t) ->
            Ojs.float_of_js
              (Ojs.call (t_to_js x104) "getWireFormatVersion" [||])
        let (readUint32 : t -> float) =
          fun (x105 : t) ->
            Ojs.float_of_js (Ojs.call (t_to_js x105) "readUint32" [||])
        let (readUint64 : t -> (float * float)) =
          fun (x106 : t) ->
            let x107 = Ojs.call (t_to_js x106) "readUint64" [||] in
            ((Ojs.float_of_js (Ojs.array_get x107 0)),
              (Ojs.float_of_js (Ojs.array_get x107 1)))
        let (readDouble : t -> float) =
          fun (x108 : t) ->
            Ojs.float_of_js (Ojs.call (t_to_js x108) "readDouble" [||])
        let (readRawBytes : t -> length:float -> Buffer.t) =
          fun (x110 : t) ->
            fun ~length:(x109 : float) ->
              Buffer.t_of_js
                (Ojs.call (t_to_js x110) "readRawBytes"
                   [|(Ojs.float_to_js x109)|])
      end
    module DefaultDeserializer =
      struct
        type t = v8_DefaultDeserializer
        let rec t_of_js : Ojs.t -> t =
          fun (x112 : Ojs.t) -> v8_DefaultDeserializer_of_js x112
        and t_to_js : t -> Ojs.t =
          fun (x111 : v8_DefaultDeserializer) ->
            v8_DefaultDeserializer_to_js x111
        let (cast : t -> v8_Deserializer) =
          fun (x113 : t) -> v8_Deserializer_of_js (t_to_js x113)
      end
    let (serialize : value:any -> Buffer.t) =
      fun ~value:(x114 : any) ->
        Buffer.t_of_js (Ojs.call Import.v8 "serialize" [|(any_to_js x114)|])
    let (deserialize : data:TypedArray.t -> any) =
      fun ~data:(x115 : TypedArray.t) ->
        any_of_js
          (Ojs.call Import.v8 "deserialize" [|(TypedArray.t_to_js x115)|])
  end
