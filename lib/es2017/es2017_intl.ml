[@@@js.dummy "!! This code has been generated by gen_js_api !!"]
[@@@ocaml.warning "-7-32-39"]
[@@@ocaml.warning "-7-11-32-33-39"]
open Es2016
module Intl =
  struct
    include struct include Intl end
    module DateTimeFormatPartTypes =
      struct
        type t =
          [ `day  | `dayPeriod  | `era  | `hour  | `literal  | `minute 
          | `month  | `second  | `timeZoneName  | `weekday  | `year ]
        let rec t_of_js : Ojs.t -> t =
          fun (x2 : Ojs.t) ->
            let x3 = x2 in
            match Ojs.string_of_js x3 with
            | "day" -> `day
            | "dayPeriod" -> `dayPeriod
            | "era" -> `era
            | "hour" -> `hour
            | "literal" -> `literal
            | "minute" -> `minute
            | "month" -> `month
            | "second" -> `second
            | "timeZoneName" -> `timeZoneName
            | "weekday" -> `weekday
            | "year" -> `year
            | _ -> assert false
        and t_to_js : t -> Ojs.t =
          fun
            (x1 :
              [ `day  | `dayPeriod  | `era  | `hour  | `literal  | `minute 
              | `month  | `second  | `timeZoneName  | `weekday  | `year ])
            ->
            match x1 with
            | `day -> Ojs.string_to_js "day"
            | `dayPeriod -> Ojs.string_to_js "dayPeriod"
            | `era -> Ojs.string_to_js "era"
            | `hour -> Ojs.string_to_js "hour"
            | `literal -> Ojs.string_to_js "literal"
            | `minute -> Ojs.string_to_js "minute"
            | `month -> Ojs.string_to_js "month"
            | `second -> Ojs.string_to_js "second"
            | `timeZoneName -> Ojs.string_to_js "timeZoneName"
            | `weekday -> Ojs.string_to_js "weekday"
            | `year -> Ojs.string_to_js "year"
      end
    module DateTimeFormatPart =
      struct
        type t = Ojs.t
        let rec t_of_js : Ojs.t -> t = fun (x5 : Ojs.t) -> x5
        and t_to_js : t -> Ojs.t = fun (x4 : Ojs.t) -> x4
        let (get_type : t -> DateTimeFormatPartTypes.t) =
          fun (x6 : t) ->
            DateTimeFormatPartTypes.t_of_js
              (Ojs.get_prop_ascii (t_to_js x6) "type")
        let (set_type : t -> DateTimeFormatPartTypes.t -> unit) =
          fun (x7 : t) ->
            fun (x8 : DateTimeFormatPartTypes.t) ->
              Ojs.set_prop_ascii (t_to_js x7) "type"
                (DateTimeFormatPartTypes.t_to_js x8)
        let (get_value : t -> string) =
          fun (x9 : t) ->
            Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x9) "value")
        let (set_value : t -> string -> unit) =
          fun (x10 : t) ->
            fun (x11 : string) ->
              Ojs.set_prop_ascii (t_to_js x10) "value" (Ojs.string_to_js x11)
      end
    module DateTimeFormat =
      struct
        include struct include DateTimeFormat end
        let (format_to_parts :
          t -> ?date:Date.t or_number -> unit -> DateTimeFormatPart.t list) =
          fun (x16 : t) ->
            fun ?date:(x12 : Date.t or_number option) ->
              fun () ->
                Ojs.list_of_js DateTimeFormatPart.t_of_js
                  (let x17 = t_to_js x16 in
                   Ojs.call (Ojs.get_prop_ascii x17 "formatToParts") "apply"
                     [|x17;((let x13 =
                               Ojs.new_obj
                                 (Ojs.get_prop_ascii Ojs.global "Array") 
                                 [||] in
                             (match x12 with
                              | Some x14 ->
                                  ignore
                                    (Ojs.call x13 "push"
                                       [|(or_number_to_js Date.t_to_js x14)|])
                              | None -> ());
                             x13))|])
      end
  end
